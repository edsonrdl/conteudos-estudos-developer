### **1. REQUIRED**

- **Comportamento:**
    
    Reutiliza uma transação ativa ou cria uma nova se nenhuma estiver ativa.
    
    Todas as operações no método são **parte de uma única unidade atômica**.
    
- **Exemplo real:** Processamento de pedido, incluindo atualização de estoque e registro de pagamento:
    
    ```java
    @Transactional(propagation = Propagation.REQUIRED)
    public void processarPedido(Long pedidoId) {
        atualizarEstoque(pedidoId);  // Primeira operação
        registrarPagamento(pedidoId);  // Segunda operação
    }
    
    ```
    
    - **Motivo:** Garante que o estoque e o pagamento sejam atualizados [juntos.Se](http://juntos.Se) uma falhar, ambas as operações serão revertidas.

---

### **2. REQUIRES_NEW**

- **Comportamento**
    
    Cria uma **nova transação independente**, suspendendo qualquer transação existente.
    
    Ideal para **tarefas que não podem falhar junto com a transação principal**.
    
- **Exemplo real:** Enviar uma notificação para o cliente após confirmar o pedido:
    
    ```java
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void enviarNotificacao(String mensagem) {
        notificacaoRepository.save(new Notificacao(mensagem));
    }
    ```
    
    - **Motivo:**Mesmo que a transação principal de processamento do pedido falhe, a notificação deve ser enviada.

---

### **3. SUPPORTS**

- **Comportamento:**
    
    Participa de uma transação ativa, se houver, ou executa sem transação.
    
    Perfeito para **operações de leitura simples** que podem ser feitas sem atomicidade.
    
- **Exemplo real:** Consultar o status de um pedido para exibição:
    
    ```java
    @Transactional(propagation = Propagation.SUPPORTS)
    public Pedido consultarStatus(Long pedidoId) {
        return pedidoRepository.findById(pedidoId).orElseThrow();
    }
    ```
    
    - **Motivo:**Como a consulta é apenas leitura, a transação pode ser opcional.

---

### **4. NOT_SUPPORTED**

- **Comportamento:**
    
    O método **sempre será executado fora de uma transação**, suspendendo qualquer transação ativa.
    
- **Exemplo real:** Gerar relatórios extensos de vendas:
    
    ```java
    @Transactional(propagation = Propagation.NOT_SUPPORTED)
    public List<Relatorio> gerarRelatorio() {
        return relatorioRepository.findAll();
    }
    
    ```
    
    - **Motivo:**Relatórios geralmente envolvem consultas de longa duração e não precisam de transações.

---

### **5. MANDATORY**

- **Comportamento:**
    
    Exige que uma transação ativa já exista. Se não houver, lança uma exceção.
    
    Útil para **métodos que dependem de um contexto transacional existente.**
    
- **Exemplo real:** Validar o limite de crédito de um cliente antes de aprovar um pedido:
    
    ```java
    @Transactional(propagation = Propagation.MANDATORY)
    public void validarLimiteCredito(Long clienteId, BigDecimal valor) {
        if (!clienteService.temLimiteSuficiente(clienteId, valor)) {
            throw new LimiteExcedidoException();
        }
    }
    ```
    
    - **Motivo:**A validação só faz sentido dentro do fluxo transacional do pedido.

---

### **6. NEVER**

- **Comportamento:**
    
    O método **não pode ser executado dentro de uma transação**.
    
    Lança uma exceção se uma transação estiver ativa.
    
- **Exemplo real:** Carregar configurações de sistema que não precisam de transação:
    
    ```java
    @Transactional(propagation = Propagation.NEVER)
    public void carregarConfiguracoes() {
        configuracaoService.carregar();
    }
    
    ```
    
    - **Motivo:**Operações de inicialização ou configuração não precisam de transações.

---

### **7. NESTED**

- **Comportamento:**
    
    Cria uma **transação aninhada** dentro da transação principal.
    
    A transação aninhada pode ser revertida sem invalidar a transação principal, mas depende do suporte do banco de dados.
    
- **Exemplo real:** Cancelar um item de um pedido sem afetar os demais:
    
    ```java
    @Transactional(propagation = Propagation.NESTED)
    public void cancelarItem(Long itemId) {
        itemPedidoRepository.cancelar(itemId);
    }
    ```
    
    - **Motivo:**Se algo der errado ao cancelar o item, somente essa operação será revertida, mantendo o restante do pedido intacto.

---

### **Configurações Avançadas do Spring Boot**

Além dos tipos de propagação, o Spring Boot permite configurar:

1. **Rollback para exceções específicas:**
    
    - Exemplo:
        
        ```java
        @Transactional(rollbackFor = {IOException.class})
        public void processarArquivo() throws IOException {
            // Processa arquivo e lança IOException em caso de erro
        }
        ```
        
    - **Motivo:**Apenas erros específicos disparam o rollback, permitindo maior controle.
        
2. **Timeout:**
    
    Define o tempo máximo que a transação pode durar antes de ser encerrada.
    
    - Exemplo:
        
        ```java
        @Transactional(timeout = 5)
        public void processarDadosLentos() {
            // Operação que deve ser finalizada em 5 segundos
        }
        ```
        
3. **Isolamento:**
    
    Permite ajustar o nível de isolamento, como **READ_COMMITTED** ou **SERIALIZABLE**, para evitar problemas de concorrência.
    
    Observação: Isolation.SERIALIZABLE ⇒ Importante para isolar transações para confiabilidade no processo de ETL e ELT .
    
    - Exemplo:
        
        ```java
        @Transactional(isolation = Isolation.REPEATABLE_READ)
        public void consultarSaldo() {
            // Operação de leitura consistente
        }
        
        ```
        

---

### **Resumo: Características e Necessidades no Spring Boot**