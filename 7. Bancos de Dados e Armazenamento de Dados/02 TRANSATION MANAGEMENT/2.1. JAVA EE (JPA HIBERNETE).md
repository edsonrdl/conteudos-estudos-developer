### **REQUIRED**

- **Comportamento:**
    
    Se já existir uma transação ativa, o método participará dessa transação. Caso contrário, ele criará uma nova transação. Isso garante que todas as operações executadas dentro do método sejam parte de uma única unidade transacional.
    
- **Exemplo real:**
    
    Imagine um método que debita de uma conta e credita em outra. O método **precisa garantir que ambas as operações ocorram juntas** ou nenhuma seja aplicada.
    
    ```java
    
    @Transactional(propagation = Propagation.REQUIRED)
    public void transferirDinheiro(Long contaOrigem, Long contaDestino, BigDecimal valor) {
        debitar(contaOrigem, valor);  // Primeira operação
        creditar(contaDestino, valor); // Segunda operação
    }
    
    ```
    
    - **Por que usar:**O `REQUIRED` permite que, se o método já estiver em uma transação, ele continue na mesma. Caso contrário, uma nova transação será criada automaticamente.
    - **Exemplo técnico:**Se a operação de débito falhar (ex: saldo insuficiente), o sistema executará um **rollback** de todas as operações no método, garantindo consistência.

---

### **REQUIRES_NEW**

- **Comportamento:**
    
    Cria uma **nova transação independente**. Se já existir uma transação ativa, ela será **suspensa** até que a nova transação seja concluída.
    
- **Exemplo real:**
    
    Registrar logs de auditoria, mesmo que a transação principal falhe.
    
    ```java
    java
    Copiar código
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void registrarLog(String mensagem) {
        logRepository.save(new Log(mensagem));
    }
    
    ```
    
    - **Por que usar:**A operação de log deve ser concluída independentemente do sucesso ou falha da transação principal.
        - **Exemplo técnico:**Se `registrarLog` falhar, somente a transação de log será revertida, e não a transação principal.

---

### **SUPPORTS**

- **Comportamento:**
    
    O método **pode ou não** participar de uma transação existente. Se houver uma transação ativa, ele será incluído. Caso contrário, será executado sem transação.
    
- **Exemplo real:**
    
    Consultar o saldo de uma conta para exibição ao usuário.
    
    ```java
    java
    Copiar código
    @Transactional(propagation = Propagation.SUPPORTS)
    public BigDecimal consultarSaldo(Long contaId) {
        return contaRepository.findSaldoById(contaId);
    }
    
    ```
    
    - **Por que usar:**Operações de consulta não precisam de transação, pois não alteram o estado do banco de dados. Usar `SUPPORTS` evita o overhead desnecessário de abrir uma transação.

---

### **NOT_SUPPORTED**

- **Comportamento:**
    
    Executa o método **fora de qualquer transação**. Se houver uma transação ativa, ela será suspensa durante a execução do método.
    
- **Exemplo real:**
    
    Gerar um relatório que envolve várias consultas.
    
    ```java
    java
    Copiar código
    @Transactional(propagation = Propagation.NOT_SUPPORTED)
    public List<Movimentacao> gerarRelatorio() {
        return movimentacaoRepository.findAll();
    }
    
    ```
    
    - **Por que usar:**Evita que operações longas mantenham uma transação aberta, o que consome recursos e pode bloquear outros processos.

---

### **MANDATORY**

- **Comportamento:**
    
    Exige que o método seja chamado dentro de uma transação existente. Se não houver uma transação ativa, uma exceção será lançada.
    
- **Exemplo real:**
    
    Validar se a conta tem saldo suficiente antes de debitar:
    
    ```java
    java
    Copiar código
    @Transactional(propagation = Propagation.MANDATORY)
    public void validarSaldo(Long contaId, BigDecimal valor) {
        if (consultarSaldo(contaId).compareTo(valor) < 0) {
            throw new SaldoInsuficienteException();
        }
    }
    
    ```
    
    - **Por que usar:**Esse método só faz sentido dentro de um fluxo transacional maior, como uma transferência bancária.

---

### **NEVER**

- **Comportamento:**
    
    Garante que o método **nunca** seja executado dentro de uma transação. Se uma transação ativa estiver presente, lança uma exceção.
    
- **Exemplo real:**
    
    Inicializar configurações de sistema que não envolvem transações:
    
    ```java
    java
    Copiar código
    @Transactional(propagation = Propagation.NEVER)
    public void carregarConfiguracoes() {
        configuracaoService.carregar();
    }
    
    ```
    
    - **Por que usar:**Este método não depende de consistência transacional e deve ser isolado.

---

### **NESTED**

- **Comportamento:**
    
    Cria uma **transação aninhada** dentro da transação principal. Se ocorrer um erro, apenas a transação aninhada será revertida, enquanto a transação principal permanece ativa.
    
- **Exemplo real:**
    
    Cancelar uma subordem sem afetar a transação principal:
    
    ```java
    java
    Copiar código
    @Transactional(propagation = Propagation.NESTED)
    public void cancelarSubordem(Long subordemId) {
        subordemRepository.cancelar(subordemId);
    }
    
    ```
    
    - **Por que usar:**Em fluxos complexos, algumas partes podem falhar sem invalidar toda a transação.

---

## **Resumo: Características e Necessidades**

|Tipo|Característica Técnica|Necessidade|
|---|---|---|
|**REQUIRED**|Reutiliza ou cria uma transação.|Garantir atomicidade em fluxos principais.|
|**REQUIRES_NEW**|Cria uma transação independente.|Isolar operações críticas, como logs ou auditorias.|
|**SUPPORTS**|Participa de transação ativa, se existir.|Leitura de dados sem necessidade de consistência transacional.|
|**NOT_SUPPORTED**|Suspende a transação ativa durante a execução.|Evitar overhead transacional em tarefas longas ou não críticas.|
|**MANDATORY**|Exige transação ativa.|Métodos que só fazem sentido dentro de um fluxo transacional maior.|
|**NEVER**|Proíbe execução dentro de uma transação.|Operações completamente independentes.|
|**NESTED**|Cria uma transação aninhada que pode ser revertida independentemente.|Subtarefas que podem falhar sem invalidar a transação principal.|

---