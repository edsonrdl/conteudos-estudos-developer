### **1. Required**

- **Comportamento:**
    
    Reutiliza uma transação ativa se ela existir; caso contrário, cria uma nova transação.
    
    Esse é o comportamento padrão para métodos transacionais no Entity Framework.
    
- **Exemplo real:** Atualizar estoque e registrar uma venda em uma transação única:
    
    ```csharp
    using (var transaction = dbContext.Database.BeginTransaction())
    {
        try
        {
            AtualizarEstoque(produtoId, quantidade);  // Primeira operação
            RegistrarVenda(vendaId);  // Segunda operação
            dbContext.SaveChanges();
            transaction.Commit();
        }
        catch
        {
            transaction.Rollback();
        }
    }
    
    ```
    
    - **Motivo:**Garante que todas as operações (atualizar estoque e registrar venda) sejam [atômicas.Se](http://xn--atmicas-u0a.Se) qualquer uma falhar, ambas serão revertidas, garantindo consistência.

---

### **2. RequiresNew**

- **Comportamento:**
    
    Cria uma **nova transação separada** da transação principal.
    
    Se houver uma transação ativa, ela será **suspensa** durante a execução da nova transação.
    
- **Exemplo real:** Registrar logs de auditoria para eventos críticos:
    
    ```csharp
    using (var scope = new TransactionScope(TransactionScopeOption.RequiresNew))
    {
        try
        {
            SalvarLog("Transação iniciada com sucesso.");
            scope.Complete();
        }
        catch
        {
            // Erro no log não afeta a transação principal
        }
    }
    
    ```
    
    - **Motivo:**Logs de auditoria devem ser gravados mesmo que a transação principal falhe.`RequiresNew` isola completamente o log da transação atual.

---

### **3. Suppress**

- **Comportamento:**
    
    Executa o método **fora de qualquer transação**.
    
    Se houver uma transação ativa, ela será ignorada para o escopo do método.
    
- **Exemplo real:** Gerar relatórios analíticos de pedidos:
    
    ```csharp
    using (var scope = new TransactionScope(TransactionScopeOption.Suppress))
    {
        var pedidos = ObterRelatorioPedidos();
        // Operações fora de transação
    }
    
    ```
    
    - **Motivo:**Relatórios não precisam de consistência transacional e não devem manter uma transação aberta para evitar bloqueios no banco de dados.

---

### **Configuração de Níveis de Isolamento**

No **Entity Framework**, você pode configurar o nível de isolamento da transação para controlar como ela interage com outras transações.

- **Exemplo com `Serializable`:**Garantir que nenhuma outra transação leia ou escreva nos mesmos dados até que a transação seja concluída.
    
    ```csharp
    using (var transaction = dbContext.Database.BeginTransaction(IsolationLevel.Serializable))
    {
        try
        {
            AtualizarEstoque(produtoId, quantidade);
            dbContext.SaveChanges();
            transaction.Commit();
        }
        catch
        {
            transaction.Rollback();
        }
    }
    
    ```
    
    - **Motivo:**O nível `Serializable` é o mais seguro, mas pode causar redução de desempenho. Use-o em cenários críticos, como controle de inventário.

---

### **Rollback Programado**

O Entity Framework permite programar o rollback manualmente em caso de falhas específicas.

- **Exemplo real:** Cancelar a transação se o cliente não tiver limite suficiente para a compra:
    
    ```csharp
    using (var transaction = dbContext.Database.BeginTransaction())
    {
        try
        {
            if (!ValidarLimite(clienteId, valor)) throw new Exception("Limite insuficiente");
            AtualizarEstoque(produtoId, quantidade);
            RegistrarVenda(vendaId);
            dbContext.SaveChanges();
            transaction.Commit();
        }
        catch
        {
            transaction.Rollback();
            throw;
        }
    }
    
    ```
    
    - **Motivo:**Garante que nenhuma alteração seja aplicada se o cliente não atender aos critérios.

---

### **Timeout de Transação**

Você pode configurar o tempo máximo permitido para uma transação antes que ela seja automaticamente cancelada.

- **Exemplo real:** Processamento de grandes lotes de dados:
    
    ```csharp
    using (var transaction = dbContext.Database.BeginTransaction())
    {
        dbContext.Database.ExecuteSqlCommand("SET TRANSACTION TIMEOUT 30000");
        // Operações
        transaction.Commit();
    }
    
    ```
    
    - **Motivo:**Limitar o tempo de execução previne bloqueios no banco de dados.

---

### **Casos de Uso Resumidos no [ASP.NET](http://ASP.NET) Core**