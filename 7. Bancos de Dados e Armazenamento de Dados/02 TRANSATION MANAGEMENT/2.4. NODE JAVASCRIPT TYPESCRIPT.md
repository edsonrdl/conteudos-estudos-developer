### **Node.js (JavaScript/TypeScript): Gerenciamento de Transações**

No **Node.js**, o gerenciamento de transações depende do ORM usado, como **Sequelize**, **TypeORM** ou **Mongoose** (para bancos NoSQL como MongoDB). Cada ORM oferece mecanismos específicos para lidar com transações. Abaixo, detalho o comportamento, casos de uso e exemplos para cada um.

---

## **1. Sequelize (MySQL/PostgreSQL)**

### **Comportamento de Transações no Sequelize**

No Sequelize, você pode gerenciar transações de forma manual ou automática. Transações permitem agrupar operações, garantindo que todas sejam confirmadas juntas (commit) ou revertidas (rollback) em caso de falha.

### **1.1. Exemplo com Transação Simples**

- **Exemplo real:** Inserir um novo usuário e criar um pedido associado:

```jsx
const sequelize = require('sequelize');

async function criarPedidoComUsuario() {
    const t = await sequelize.transaction();
    try {
        const usuario = await Usuario.create({ nome: 'João' }, { transaction: t });
        await Pedido.create({ usuarioId: usuario.id, total: 100 }, { transaction: t });
        await t.commit(); // Confirma as operações
    } catch (error) {
        await t.rollback(); // Reverte as operações
        throw error;
    }
}

```

- **Motivo:**Garante que o usuário e o pedido sejam criados juntos. Se ocorrer erro em uma das operações, ambas são revertidas.

### **1.2. Transação Automática**

- **Exemplo real:** Usar a função `sequelize.transaction()` com um callback para simplificar o código:

```jsx

async function criarPedidoComUsuario() {
    await sequelize.transaction(async (t) => {
        const usuario = await Usuario.create({ nome: 'João' }, { transaction: t });
        await Pedido.create({ usuarioId: usuario.id, total: 100 }, { transaction: t });
    });
}

```

- **Motivo:**O Sequelize gerencia automaticamente o commit ou rollback, reduzindo o risco de esquecer algum passo.

---

### **1.3. Nível de Isolamento no Sequelize**

Você pode definir o nível de isolamento para controlar como a transação interage com outras operações no banco de dados.

- **Exemplo com `SERIALIZABLE`:**

```jsx
const { Sequelize, Transaction } = require('sequelize');

async function operacaoIsolada() {
    await sequelize.transaction({ isolationLevel: Transaction.ISOLATION_LEVELS.SERIALIZABLE }, async (t) => {
        // Operações aqui serão isoladas
        await Usuario.update({ saldo: 50 }, { where: { id: 1 }, transaction: t });
    });
}
```

- **Motivo:**`SERIALIZABLE` é usado para cenários críticos onde nenhuma outra transação pode alterar os mesmos dados simultaneamente.

---

## **2. TypeORM (MySQL/PostgreSQL)**

### **Comportamento de Transações no TypeORM**

O TypeORM usa a API de gerenciadores de transações (`EntityManager`) para agrupar operações de forma segura.

### **2.1. Exemplo com Transações**

- **Exemplo real:** Criar uma nova ordem de compra e atualizar o estoque:

```tsx
import { getConnection } from 'typeorm';

async function criarOrdemComEstoque() {
    await getConnection().transaction(async (manager) => {
        const ordem = await manager.save(Ordem, { clienteId: 1, total: 200 });
        await manager.update(Produto, { id: 1 }, { estoque: () => 'estoque - 1' });
    });
}
```

- **Motivo:**Garante que a criação da ordem e a atualização do estoque ocorram juntas, evitando inconsistências.

### **2.2. Nível de Isolamento no TypeORM**

Assim como no Sequelize, você pode configurar o isolamento para evitar conflitos.

- **Exemplo com `READ COMMITTED`:**

```tsx
await getConnection().transaction(
    { isolation: 'READ COMMITTED' },
    async (manager) => {
        // Operações transacionais aqui
        const produto = await manager.findOne(Produto, { id: 1 });
        produto.preco = produto.preco * 1.1;
        await manager.save(produto);
    }
);
```

- **Motivo:**O nível `READ COMMITTED` evita leituras sujas enquanto melhora o desempenho em comparação com `SERIALIZABLE`.

---

## **3. Mongoose (MongoDB)**

### **Comportamento de Transações no Mongoose**

O Mongoose oferece suporte a transações usando sessões do MongoDB. Isso permite gerenciar operações atômicas em documentos.

### **3.1. Exemplo com Sessão de Transação**

- **Exemplo real:** Atualizar dois documentos dependentes:

```jsx
const mongoose = require('mongoose');

async function atualizarDocumentos() {
    const session = await mongoose.startSession();
    session.startTransaction();
    try {
        await Usuario.updateOne({ _id: usuarioId }, { saldo: 50 }, { session });
        await Conta.updateOne({ _id: contaId }, { limite: 1000 }, { session });
        await session.commitTransaction(); // Confirma as operações
    } catch (error) {
        await session.abortTransaction(); // Reverte as operações
        throw error;
    } finally {
        session.endSession();
    }
}
```

- **Motivo:**Garante que as atualizações em `Usuario` e `Conta` sejam aplicadas juntas ou revertidas em caso de falha.

### **3.2. Limitações no Mongoose**

- **Quando evitar:**Em operações simples ou consultas que não exigem consistência transacional. Transações no MongoDB podem ser mais custosas em termos de desempenho.

---

## **Casos de Uso Resumidos no Node.js**