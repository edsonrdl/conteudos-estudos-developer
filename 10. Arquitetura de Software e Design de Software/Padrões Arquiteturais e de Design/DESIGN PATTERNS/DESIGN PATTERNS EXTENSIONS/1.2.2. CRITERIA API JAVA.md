A **Criteria API** do **JPA (Java Persistence API)** é uma forma de construir consultas dinâmicas e programáticas, utilizando uma abordagem orientada a objetos. Ela é uma alternativa ao uso de **JPQL** (Java Persistence Query Language) e oferece uma maneira de criar consultas **tipadas** e **seguras** em tempo de compilação.

### **O que é a Criteria API?**

A **Criteria API** permite construir consultas SQL-like de forma programática e tipada, utilizando **objetos Java**. Em vez de escrever uma consulta JPQL diretamente como uma string, você utiliza a Criteria API para construir a consulta de maneira fluida, programática e dinâmica.

A **Criteria API** é baseada em três componentes principais:

1. **`CriteriaBuilder`**: Um utilitário para criar partes da consulta, como condições, expressões e predicados.
2. **`CriteriaQuery`**: Representa a consulta que você deseja construir.
3. **`Root`**: Representa a tabela (ou entidade) sobre a qual você está consultando.

### **Casos de Uso da Criteria API**

A **Criteria API** é útil principalmente em cenários onde você precisa:

- **Consultas dinâmicas**: Quando as condições da consulta podem variar com base em parâmetros fornecidos.
- **Consultas complexas**: Como quando você tem **INNER JOIN**, **GROUP BY**, ou **HAVING** e precisa de uma forma programática de construir a consulta.
- **Segurança em tempo de compilação**: Ao contrário do uso de strings em JPQL, a Criteria API usa tipos Java, garantindo que a consulta seja validada em tempo de compilação.

### **Exemplo de Uso do Criteria API com INNER JOIN**

Vamos usar um exemplo de duas entidades: `Produto` e `Categoria`. O objetivo será realizar uma consulta para obter **produtos** de uma **categoria específica** usando um **INNER JOIN**.

### **Entidades**

1. **Produto**: Tem um relacionamento Many-to-One com **Categoria**.
2. **Categoria**: Representa uma categoria de produto.

### **ProdutoEntity**

```java

@Entity
public class Produto {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String nome;
    private Double preco;

    @ManyToOne
    @JoinColumn(name = "categoria_id")
    private Categoria categoria; // Relacionamento Many-to-One

    // Getters e Setters
}

```

### **CategoriaEntity**

```java

@Entity
public class Categoria {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String nome;

    // Getters e Setters
}

```

### **Implementando uma Consulta com INNER JOIN usando Criteria API**

Agora, vamos implementar uma consulta utilizando a Criteria API para buscar **produtos** de uma **categoria** específica.

### **Código do Repositório usando Criteria API**

```java
import org.springframework.stereotype.Repository;
import org.springframework.data.jpa.repository.JpaRepository;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.criteria.*;

import java.util.List;

@Repository
public class ProdutoRepository {

    @PersistenceContext
    private EntityManager entityManager;

    public List<Produto> buscarProdutosPorCategoria(String nomeCategoria) {
        // Criando o CriteriaBuilder
        CriteriaBuilder cb = entityManager.getCriteriaBuilder();

        // Criando a CriteriaQuery (representa a consulta)
        CriteriaQuery<Produto> query = cb.createQuery(Produto.class);

        // Definindo a "root" (tabela principal, Produto)
        Root<Produto> produtoRoot = query.from(Produto.class);

        // Realizando o INNER JOIN com a tabela Categoria
        Join<Produto, Categoria> categoriaJoin = produtoRoot.join("categoria", JoinType.INNER);

        // Definindo as condições de filtragem (onde a categoria nome é igual ao fornecido)
        Predicate categoriaPredicate = cb.equal(categoriaJoin.get("nome"), nomeCategoria);

        // Aplicando a condição ao CriteriaQuery
        query.select(produtoRoot).where(categoriaPredicate);

        // Executando a consulta e retornando o resultado
        return entityManager.createQuery(query).getResultList();
    }
}

```

### **Explicação do Código:**

1. **CriteriaBuilder (`cb`)**: O `CriteriaBuilder` é utilizado para criar as partes da consulta, como a condição de `JOIN` e os predicados.
2. **CriteriaQuery (`query`)**: O `CriteriaQuery` representa a consulta final que será executada. Aqui, estamos buscando instâncias da entidade `Produto`.
3. **Root (`produtoRoot`)**: Representa a tabela principal (entidade `Produto`).
4. **Join (`categoriaJoin`)**: O `join` é utilizado para realizar o **INNER JOIN** entre a entidade `Produto` e `Categoria`.
5. **Predicate (`categoriaPredicate`)**: O `Predicate` é a condição para filtrar os produtos pela categoria, verificando se o nome da categoria corresponde ao parâmetro fornecido.
6. **Execução**: A consulta é executada através do `entityManager.createQuery(query).getResultList()` para obter a lista de produtos.

### **Cenários de Uso Comuns da Criteria API**

1. **Consultas Dinâmicas**:
    - Quando os filtros podem variar dependendo dos parâmetros da requisição.
    - Exemplo: Em um sistema de busca de produtos, você pode filtrar por categoria, preço, nome, etc. de maneira dinâmica.
2. **Consultas Complexas**:
    - Quando você precisa fazer **INNER JOINs**, **LEFT JOINs**, ou outras operações complexas de SQL que não podem ser facilmente expressas com JPQL.
    - Exemplo: Ao buscar dados de múltiplas tabelas com junções, agregações ou agrupamentos.
3. **Validação e Segurança em Tempo de Compilação**:
    - Como a Criteria API é tipada, os erros de sintaxe ou de referência de campo (como erros de nome de campo) são detectados em tempo de compilação, ao contrário das strings no JPQL.

### **Exemplo de Caso de Uso: Filtrar Produtos por Categoria e Preço**

Se quisermos filtrar produtos de uma categoria específica e com preço maior que um valor mínimo, podemos construir uma consulta dinâmica dessa forma:

```java

public List<Produto> buscarProdutosPorCategoriaEPreco(String nomeCategoria, Double precoMinimo) {
    CriteriaBuilder cb = entityManager.getCriteriaBuilder();
    CriteriaQuery<Produto> query = cb.createQuery(Produto.class);
    Root<Produto> produtoRoot = query.from(Produto.class);

    // INNER JOIN com Categoria
    Join<Produto, Categoria> categoriaJoin = produtoRoot.join("categoria", JoinType.INNER);

    // Filtros de categoria e preço
    Predicate categoriaPredicate = cb.equal(categoriaJoin.get("nome"), nomeCategoria);
    Predicate precoPredicate = cb.greaterThanOrEqualTo(produtoRoot.get("preco"), precoMinimo);

    // Aplicando os filtros à consulta
    query.select(produtoRoot).where(cb.and(categoriaPredicate, precoPredicate));

    // Executando a consulta
    return entityManager.createQuery(query).getResultList();
}

```

Neste exemplo, estamos filtrando **produtos** que pertencem a uma **categoria** e têm um **preço maior ou igual** a um valor específico. Utilizamos a **Criteria API** para criar dinamicamente as condições e a junção entre `Produto` e `Categoria`.

---

### **Vantagens da Criteria API**

1. **Consultas Dinâmicas**: A Criteria API é excelente para cenários onde as condições de busca mudam dinamicamente com base nas entradas do usuário.
2. **Segurança de Tipos**: Ao contrário de escrever uma consulta JPQL como string, a Criteria API garante que os tipos sejam verificados em tempo de compilação.
3. **Composição de Consultas**: Você pode construir consultas complexas combinando várias especificações e condições.
4. **Portabilidade e Flexibilidade**: A Criteria API é independente de banco de dados, funcionando da mesma maneira com diferentes implementações JPA (como Hibernate, EclipseLink, etc.).

### **Conclusão**

A **Criteria API** é uma ferramenta poderosa para criar consultas dinâmicas, tipadas e seguras em Java, especialmente útil quando se trabalha com operações complexas de banco de dados. Ela permite criar consultas programáticas com **INNER JOINs**, **filtros dinâmicos** e **condições complexas** de forma flexível e segura, evitando problemas como erros em tempo de execução de consultas.