### **Exemplo Pr√°tico do Specification Pattern** em Java

O **Specification Pattern** √© muito √∫til para criar filtros reutiliz√°veis e combin√°veis. Ele pode ser aplicado para validar regras de neg√≥cio e construir consultas din√¢micas.

---

## üéØ **Cen√°rio: Filtrando Usu√°rios**

Vamos supor que temos um sistema que precisa filtrar usu√°rios com base em crit√©rios como:

- **Usu√°rios ativos**
- **Idade m√≠nima**
- **Nome contendo um texto espec√≠fico**

Em vez de criar v√°rias consultas separadas, podemos usar o **Specification Pattern** para compor esses filtros dinamicamente.

---

### üîπ **Passo 1: Criar a Interface Specification**

A interface define o m√©todo `isSatisfiedBy`, que verifica se um objeto atende ao crit√©rio.

```java
public interface Specification<T> {
    boolean isSatisfiedBy(T candidate);

    default Specification<T> and(Specification<T> other) {
        return candidate -> this.isSatisfiedBy(candidate) && other.isSatisfiedBy(candidate);
    }

    default Specification<T> or(Specification<T> other) {
        return candidate -> this.isSatisfiedBy(candidate) || other.isSatisfiedBy(candidate);
    }

    default Specification<T> not() {
        return candidate -> !this.isSatisfiedBy(candidate);
    }
}

```

‚úÖ **Permite combinar especifica√ß√µes com `and`, `or` e `not` dinamicamente.**

---

### üîπ **Passo 2: Criar a Classe `User`**

Definimos um modelo de **Usu√°rio**, que ser√° filtrado.

```java
public class User {
    private String name;
    private int age;
    private boolean active;

    public User(String name, int age, boolean active) {
        this.name = name;
        this.age = age;
        this.active = active;
    }

    public String getName() { return name; }
    public int getAge() { return age; }
    public boolean isActive() { return active; }
}

```

---

### üîπ **Passo 3: Criar Implementa√ß√µes de Especifica√ß√µes**

Criamos regras espec√≠ficas como classes que implementam `Specification<User>`.

```java
public class ActiveUserSpecification implements Specification<User> {
    @Override
    public boolean isSatisfiedBy(User user) {
        return user.isActive();
    }
}

public class AgeSpecification implements Specification<User> {
    private final int minAge;

    public AgeSpecification(int minAge) {
        this.minAge = minAge;
    }

    @Override
    public boolean isSatisfiedBy(User user) {
        return user.getAge() >= minAge;
    }
}

public class NameContainsSpecification implements Specification<User> {
    private final String text;

    public NameContainsSpecification(String text) {
        this.text = text;
    }

    @Override
    public boolean isSatisfiedBy(User user) {
        return user.getName().toLowerCase().contains(text.toLowerCase());
    }
}

```

‚úÖ **Cada especifica√ß√£o √© independente e pode ser reutilizada.**

---

### üîπ **Passo 4: Usar as Especifica√ß√µes**

Agora combinamos regras de forma din√¢mica.

```java
import java.util.List;
import java.util.stream.Collectors;

public class SpecificationPatternDemo {
    public static void main(String[] args) {
        List<User> users = List.of(
            new User("Alice", 25, true),
            new User("Bob", 30, false),
            new User("Charlie", 35, true),
            new User("David", 20, true),
            new User("Eve", 40, false)
        );

        // Criando especifica√ß√µes individuais
        Specification<User> activeSpec = new ActiveUserSpecification();
        Specification<User> ageSpec = new AgeSpecification(30);
        Specification<User> nameSpec = new NameContainsSpecification("a");

        // Combinando especifica√ß√µes: usu√°rios ativos E com idade m√≠nima de 30 anos
        Specification<User> complexSpec = activeSpec.and(ageSpec);

        // Filtrando a lista
        List<User> filteredUsers = users.stream()
            .filter(complexSpec::isSatisfiedBy)
            .collect(Collectors.toList());

        // Exibindo os usu√°rios filtrados
        filteredUsers.forEach(user ->
            System.out.println("Usu√°rio aprovado: " + user.getName())
        );
    }
}

```

---

### üèÜ **Sa√≠da Esperada**

Se rodarmos o c√≥digo, o output ser√°:

```
yaml
CopiarEditar
Usu√°rio aprovado: Charlie

```

Isso acontece porque:

- **Charlie** tem 35 anos (**maior que 30**) e est√° **ativo** ‚úÖ.
- **Alice** tem 25 anos (**n√£o passa** no crit√©rio da idade) ‚ùå.
- **Bob** tem 30 anos, mas n√£o est√° ativo ‚ùå.
- **David** tem 20 anos, n√£o passa na idade ‚ùå.
- **Eve** tem 40 anos, mas n√£o est√° ativa ‚ùå.

---

## üî• **Vantagens do Specification Pattern**

‚úÖ **C√≥digo modular** ‚Üí Cada especifica√ß√£o √© uma classe separada.

‚úÖ **Reutiliza√ß√£o** ‚Üí Especifica√ß√µes podem ser combinadas (`and`, `or`, `not`).

‚úÖ **Facilidade de manuten√ß√£o** ‚Üí Novas regras podem ser adicionadas sem modificar c√≥digo existente.

## ‚úÖ **Pode ser integrado com banco de dados** ‚Üí Em frameworks como **Spring Data JPA**, podemos us√°-lo para construir consultas din√¢micas.

---

### 1. Exemplo pr√°tico do **Specification Pattern** integrado ao **Spring Data JPA** usando **Criteria API**

---

## **Cen√°rio**

Temos uma tabela `User` com os seguintes atributos:

- `id` (Long)
- `name` (String)
- `age` (Integer)
- `active` (Boolean)

Queremos criar uma API para buscar usu√°rios aplicando filtros din√¢micos, como:

- Nome contendo um texto.
- Idade m√≠nima.
- Status ativo/inativo.

Vamos implementar isso usando o **Specification Pattern** + **Spring Data JPA**.

---

### 1Ô∏è‚É£ **Criar a Entidade `User`**

Essa √© a entidade JPA que representa a tabela no banco de dados.

```java
java
CopiarEditar
import jakarta.persistence.*;

@Entity
@Table(name = "users")
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private Integer age;
    private Boolean active;

    // Construtores, Getters e Setters
    public User() {}

    public User(String name, Integer age, Boolean active) {
        this.name = name;
        this.age = age;
        this.active = active;
    }

    public Long getId() { return id; }
    public String getName() { return name; }
    public Integer getAge() { return age; }
    public Boolean getActive() { return active; }
}

```

---

### 2Ô∏è‚É£ **Criar a Interface `Specification` Gen√©rica**

Aqui definimos a interface base para criar filtros reutiliz√°veis.

```java
java
CopiarEditar
import org.springframework.data.jpa.domain.Specification;

public interface SpecificationBuilder<T> {
    Specification<T> build();
}

```

‚úÖ Isso nos permite criar **filtros reutiliz√°veis** de forma fluida.

---

### 3Ô∏è‚É£ **Criar Especifica√ß√µes para os Filtros**

Cada especifica√ß√£o representa um crit√©rio de busca.

```java
import org.springframework.data.jpa.domain.Specification;
import jakarta.persistence.criteria.*;

public class UserSpecifications {

    public static Specification<User> hasName(String name) {
        return (Root<User> root, CriteriaQuery<?> query, CriteriaBuilder cb) ->
            name == null ? null : cb.like(cb.lower(root.get("name")), "%" + name.toLowerCase() + "%");
    }

    public static Specification<User> hasMinAge(Integer minAge) {
        return (Root<User> root, CriteriaQuery<?> query, CriteriaBuilder cb) ->
            minAge == null ? null : cb.greaterThanOrEqualTo(root.get("age"), minAge);
    }

    public static Specification<User> isActive(Boolean active) {
        return (Root<User> root, CriteriaQuery<?> query, CriteriaBuilder cb) ->
            active == null ? null : cb.equal(root.get("active"), active);
    }
}

```

‚úÖ Cada m√©todo retorna uma especifica√ß√£o condicional.

‚úÖ Se o filtro for `null`, ele n√£o aplica o crit√©rio.

---

### 4Ô∏è‚É£ **Criar o Reposit√≥rio Usando Spring Data JPA**

O `JpaSpecificationExecutor` permite usar **Specifications** para buscas din√¢micas.

```java
java
CopiarEditar
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;

public interface UserRepository extends JpaRepository<User, Long>, JpaSpecificationExecutor<User> {
}

```

‚úÖ **JpaSpecificationExecutor** permite filtrar dinamicamente com `Specification<T>`.

---

### 5Ô∏è‚É£ **Criar o Servi√ßo `UserService`**

O servi√ßo combina m√∫ltiplas especifica√ß√µes.

```java
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;
import java.util.List;

@Service
public class UserService {

    private final UserRepository userRepository;

    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public List<User> searchUsers(String name, Integer minAge, Boolean active) {
        Specification<User> spec = Specification
            .where(UserSpecifications.hasName(name))
            .and(UserSpecifications.hasMinAge(minAge))
            .and(UserSpecifications.isActive(active));

        return userRepository.findAll(spec);
    }
}

```

‚úÖ **Cria√ß√£o din√¢mica** de filtros com `Specification.where()`.

‚úÖ **Os crit√©rios s√≥ s√£o aplicados se n√£o forem `null`**.

---

### 6Ô∏è‚É£ **Criar o Controller**

Criamos uma API REST para buscar usu√°rios com filtros din√¢micos.

```java
import org.springframework.web.bind.annotation.*;
import java.util.List;

@RestController
@RequestMapping("/users")
public class UserController {

    private final UserService userService;

    public UserController(UserService userService) {
        this.userService = userService;
    }

    @GetMapping("/search")
    public List<User> searchUsers(
            @RequestParam(required = false) String name,
            @RequestParam(required = false) Integer minAge,
            @RequestParam(required = false) Boolean active) {
        return userService.searchUsers(name, minAge, active);
    }
}

```

‚úÖ Essa API permite buscar usu√°rios dinamicamente, sem precisar criar m√©todos fixos no reposit√≥rio.

---

### 7Ô∏è‚É£ **Testando a API**

Rodamos a aplica√ß√£o e fazemos requisi√ß√µes:

- **Buscar todos os usu√°rios ativos com idade ‚â• 30 e nome contendo "Jo√£o"**

```
GET <http://localhost:8080/users/search?name=Jo√£o&minAge=30&active=true>
```

- **Buscar todos os usu√°rios ativos**

```
GET <http://localhost:8080/users/search?active=true>
```

- **Buscar usu√°rios sem filtro (retorna todos)**

```
GET <http://localhost:8080/users/search>
```

###  Criando relacionamentos com inner join specification

### **üéØ Cen√°rio: Filtrando Produtos com INNER JOIN entre Produto e Categoria**

Suponha que temos duas entidades: `Produto` e `Categoria`. O objetivo √© buscar **Produtos** de uma **Categoria espec√≠fica** utilizando **INNER JOIN**.

---

### **üîπ Passo 1: Definindo as Entidades**

### **ProdutoEntity**

```java
@Entity
public class Produto {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String nome;
    private Double preco;

    @ManyToOne
    @JoinColumn(name = "categoria_id")
    private Categoria categoria; // Relacionamento Many-to-One com Categoria

    // Getters e Setters
}

```

### **CategoriaEntity**

```java
@Entity
public class Categoria {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String nome;

    // Getters e Setters
}

```

### **üîπ Passo 2: Criando as Especifica√ß√µes**

Agora, vamos criar as **Especifica√ß√µes** para filtrar **Produtos** de uma **Categoria espec√≠fica** com base no nome da **Categoria** e no **pre√ßo**.

### **ProdutoSpecifications**

```java
import org.springframework.data.jpa.domain.Specification;
import jakarta.persistence.criteria.*;

public class ProdutoSpecifications {

    // Especifica√ß√£o para filtrar por categoria nome
    public static Specification<Produto> hasCategoriaNome(String categoriaNome) {
        return (Root<Produto> root, CriteriaQuery<?> query, CriteriaBuilder cb) -> {
            Join<Produto, Categoria> categoriaJoin = root.join("categoria", JoinType.INNER);
            return cb.equal(categoriaJoin.get("nome"), categoriaNome);
        };
    }

    // Especifica√ß√£o para filtrar por pre√ßo m√≠nimo
    public static Specification<Produto> hasPrecoMaiorQue(Double precoMinimo) {
        return (Root<Produto> root, CriteriaQuery<?> query, CriteriaBuilder cb) -> {
            return cb.greaterThanOrEqualTo(root.get("preco"), precoMinimo);
        };
    }
}

```

### **üîπ Passo 3: Reposit√≥rio com `JpaSpecificationExecutor`**

Agora, criamos o reposit√≥rio para usar o **`Specification`** com o **INNER JOIN**:

```java
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;

public interface ProdutoRepository extends JpaRepository<Produto, Long>, JpaSpecificationExecutor<Produto> {
}

```

### **üîπ Passo 4: Servi√ßo para Combinar as Especifica√ß√µes**

Criamos um **servi√ßo** para combinar as especifica√ß√µes e fazer a consulta no banco.

```java
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;
import java.util.List;

@Service
public class ProdutoService {

    private final ProdutoRepository produtoRepository;

    public ProdutoService(ProdutoRepository produtoRepository) {
        this.produtoRepository = produtoRepository;
    }

    // M√©todo que usa as especifica√ß√µes para filtrar os produtos
    public List<Produto> buscarProdutos(String categoriaNome, Double precoMinimo) {
        Specification<Produto> spec = Specification
            .where(ProdutoSpecifications.hasCategoriaNome(categoriaNome))
            .and(ProdutoSpecifications.hasPrecoMaiorQue(precoMinimo));

        return produtoRepository.findAll(spec);
    }
}

```

### **üîπ Passo 5: Controller para Expor a API**

Agora, criamos o **controller** para expor a funcionalidade como uma API REST.

```java
import org.springframework.web.bind.annotation.*;
import java.util.List;

@RestController
@RequestMapping("/produtos")
public class ProdutoController {

    private final ProdutoService produtoService;

    public ProdutoController(ProdutoService produtoService) {
        this.produtoService = produtoService;
    }

    @GetMapping("/buscar")
    public List<Produto> buscarProdutos(
            @RequestParam String categoria,
            @RequestParam Double precoMinimo) {
        return produtoService.buscarProdutos(categoria, precoMinimo);
    }
}

```

### **üîπ Passo 6: Testando a API**

Agora, podemos fazer uma requisi√ß√£o HTTP para buscar **Produtos** de uma **Categoria espec√≠fica** com pre√ßo maior que um valor m√≠nimo.

Exemplo de requisi√ß√£o:

```
GET <http://localhost:8080/produtos/buscar?categoria=Eletr√¥nicos&precoMinimo=500>
```

---

### **Resumo**

1. **INNER JOIN** entre `Produto` e `Categoria` foi feito dentro da especifica√ß√£o `hasCategoriaNome`.
2. Criamos um **servi√ßo** para combinar v√°rias **especifica√ß√µes** e filtrar os produtos dinamicamente.
3. Utilizamos o **JpaSpecificationExecutor** no reposit√≥rio para realizar consultas din√¢micas com base nas especifica√ß√µes.
4. A API REST permite filtrar produtos por **Categoria** e **Pre√ßo** com a ajuda do **Specification Pattern**.

Esse exemplo utiliza um **INNER JOIN** no `Produto` com a `Categoria` e filtra os produtos com base em crit√©rios definidos nas **Especifica√ß√µes**.
---

